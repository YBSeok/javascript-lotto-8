### 1. 'else' 지양 및 함수 분리 요구사항에 따른 리팩토링

**1. 상황**
당첨 등수(1등~5등, 미당첨)를 판별하는 로직을 구현해야 했다. 6개 일치, 5개+보너스 일치, 5개 일치 등 조건이 복잡하여, 처음에는 `if-else if-else` 구문이 겹겹이 쌓여 15라인을 초과하고 "else를 지양한다"는 요구사항을 위반했다.

**2. 분석**
"else 지양" 요구사항의 핵심은 "함수(메서드)가 한 가지 일만 하도록" 유도하고, "불필요한 코드의 깊이(indent)를 줄이는 것"에 있다고 판단했다. `else` 구문은 종종 해당 함수가 여러 갈래의 책임을 한 번에 처리하려 할 때 발생한다. `if` 조건에 해당할 경우, 즉시 값을 `return` 시키면 `else`로 묶을 필요가 없어진다고 파악했다.

**3. 해결**
`WinningLotto` 클래스에 `calculateRank` 메서드를 만들고, **Early Return"** 패턴을 적용했다.

1. `matchCount`와 `hasBonus`라는 명확한 변수를 먼저 계산했다.
2. 가장 까다로운 조건(1등)부터 `if`문으로 검사하고, 해당하면 즉시 `RANK.FIRST`를 `return` 했다.
3. `else` 없이 다음 `if`문에서 2등을 검사하고 즉시 `return` 했다.
4. 3등, 4등, 5등도 동일하게 처리하고, 모든 `if` 조건을 통과했다면 마지막 줄에서 `return RANK.NONE;`을 실행했다. 결과적으로 `else`를 모두 제거하고 15라인 이내의 간결한 메서드를 완성했다.

---

### 2. 클래스 협력 및 단위 테스트에 따른 책임 분리

**1. 상황**
`LottoTest.js` 단위 테스트는 `new Lotto([...])`가 호출되는 시점에 **길이(6개), 중복, 1~45 범위** 검증을 통과하지 못하면 에러를 발생시킬 것을 요구했다. 하지만 초기 구현에서는 이 유효성 검사 로직을 `Lotto` 클래스가 아닌 입력을 받는 `InputManager`나 `Validation` 유틸리티 클래스에 두려고 시도했다.

**2. 분석**
단위 테스트는 `Lotto` 클래스 자체가 **'스스로 유효성을 보장(self-validating)'**해야 함을 명확히 보여주었다. 만약 `InputManager`가 검증 책임을 모두 갖는다면, `Lotto` 클래스는 `InputManager`가 항상 올바른 값만 넘겨줄 것이라 "신뢰"해야만 하는 **높은 결합도**가 발생한다고 판단했다. `Lotto` 객체는 생성 시점부터 스스로의 유효성을 증명해야 객체의 **응집도**가 높아진다고 결론 내렸다.

**3. 해결**
`Lotto` 클래스의 `constructor`가 비공개 메서드인 `#validate`를 호출하도록 책임을 위임했다. `#validate` 메서드 내부에 **길이, 중복, 1~45 범위**를 검사하는 모든 로직을 구현했다. 결과적으로 `Lotto` 클래스는 다른 클래스의 구현에 의존하지 않는 '독립적인 객체'가 되었으며, 단위 테스트를 성공적으로 통과시켰다.
